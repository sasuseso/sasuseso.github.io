@def title = "Julia Style Guide (japanese)"
@def tags = ["julia"]

Julia Style Guide
=================

<https://docs.julialang.org/en/v1/manual/style-guide/index.html>のメモ  

以下はJuliaの慣用的なコーディングスタイルをまとめたものです｡このガイドは絶対で
はなくJulia言語の上達の助けであり,設計の幅を広げるための提案です｡


関数にまとめる
--------------

Top-levelスコープにロジックを書きなぐれば問題自体は早く解決しますが,それらはで
きるだけ早く関数にまとめるべきです｡関数にすることで書かれている処理が明確になり
,再利用とテストが簡単になります｡更にJuliaのコンパイラによって関数内の処理は
top-levelのものより実行が高速になります｡また関数はできるだけ引数を取るように設
計してグローバル変数へのアクセスは押さえるべきです｡([pi][1]などの定数は例外)


型を制限しすぎない
------------------

コードは可能な限り一般化されるべきです
```julia
Complex{Float64}(x)
```
上記より以下のように書かれるべきです
```julia
complex(float(x))
```
2つ目のコードは自動的に`x`を適切な型に変換します｡  

これは関数の引数についても言えます｡任意の整数を引数に取りたい場合`Int`や`Int32`
ではなく抽象型である`Integer`を使うべきです｡とは言えほとんどの場合関数の引数に
は型注釈をつける必要はありません｡指定された型を引数に取るメソッドが宣言されてい
なければ`MethodError`が投げられます｡

以下は例です｡`addone`は与えられた数値型の1と引数の和を返します｡
```julia
addone(x::Int) = x + 1
addone(x::Integer) = x + oneunit(x)
addone(x::Number) = x + oneunit(x)
addone(x) = x + oneunit(x)
```
`addone`は`oneunit`がサポートするすべての型と`+`関数が定義されている型を受け付
けます｡注目するべきは,引数に型注釈がついているものとそうでないものの間には一切
のパフォーマンスの差が無いことです｡
```
ベンチいれとこうかな
```
Juliaの処理系は自動的に最適化されたバージョンをコンパイルしてくれます｡例えば,最
初に`addone(12)`として呼び出した時,処理系は`x::Int64`に最適化された`addone`をコ
ンパイルします｡つまり,上の3つの関数宣言は4番目の`addone`の宣言と同じになります｡

型を広く取りすぎない
--------------------

```julia
function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)
```
とかく代わりに下の様に書くべきです｡
```julia
function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))
```
`foo`は実際にはすべての型を受け入れるわけではないのでこの様に書くほうが良いです｡  

ここで問題なのはこの関数が本当は整数を引数に必要としていることです｡なので呼び出
し側に整数型を強制して,他の型からの変換(例: 小数型の場合切り上げか切り捨てか)を
担保させた方が良いと思われます｡もう一つの問題は,型注釈が具体的なため将来的にメ
ソッド増える可能性があることです｡

引数にとった変数を変更する関数の名前には`!`をつける
---------------------------------------------------

```julia
function double(a::AbstractArray{<:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end
```
の代わりに
```julia
function double!(a::AbstractArray{<:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end
```
を使うべきです｡  

Juliaの標準ライブラリのBaseモジュールはこの命名規則を使った例が多くあります｡ま
た同じ機能でコピーが発生するものと引数を変更する2つのバージョンを持つ関数と(例:
sort, sort!)引数を変更するだけのものがあります(例: push!, pop!, splice!)｡変更し
た引数を返す関数にもこれは適用されます｡


変な`Union`を使わない
--------------------

`Union{Function,AbstractString}`の様な変な型を使わざるを得ないとう言うことは設
計に欠陥がある可能性を示唆しています｡


凝ったコンテナ型を避ける
------------------------

以下のような型指定で`Union`に大量の型を指定するより
```julia
a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)
```
単純に`Vector{Any}(undef, n)`として要素を利用するときに型注釈をつける(例:
`a[i]::Int`)ほうがコンパイラは喜びます｡

Juliaの`base/`で使われている命名規則を使う
-----------------------------------------

- モジュールと型はアッパーキャメルケース(例: `SparseArrays`, `struct UnitRange`)
- 関数は基本的には小文字です｡(例: `maximum`, `convert`) また,読みやすい限り複数
  の単語で構成される名前も小文字です｡(`isequal`, `haskey`) 必要ならアンダースコ
  アを単語の区切りに用います｡ アンダースコアは複合的な意味を表現したいときにも
  用います｡(`fetch(remotecall(...))`の別名として`remotecall_fetch`とします)
- 簡潔さを重視しますが,分かりにくい略語(○`indexin`, ☓`indxin`)を避けましょう｡

関数名が複数の単語を必要とするときは,それが複数の概念を表現する必要があるかどう
か考えてより良い分割がないかを考慮しましょう｡


関数の引数の順序をJuliaの`Base`を参考にする
-------------------------------------------

一般的に`Base`は以下のルールに従って引数の順序を決定しています｡

1. `Function`型: `Function`を引数とする関数は,これを第一引数とすることで`do`ブ
   ロックによって無名関数を渡すことが可能になります｡
2. I/Oストリーム: `IO`のオブジェクトを引数を最初に指定することで`sprint`の様な
   関数に`Function`を渡すことができます｡
3. ミュータブルな入力: 引数に指定された変数の値を変更する関数でミュータブルにさ
   れる引数は最初に来ます｡例えば`fill!(x, v)`では`x`がミュータブルになり,`v`に
   書換えられます｡
4. `Type`: 型が引数として与えられるときは,その関数から返る値はそこで指定された
   型であることが一般的です｡`parse(Int, "1")`では,型がパースされる文字列の前に
   来ます｡
5. イミュータブルな入力: イミュータブルな引数はミュータブルな引数の後に指定され
   ます｡(`fill!(x, v)`の`v`)
6. キー: 連想配列のキー`Array`などの他のインデックス可能なオブジェクトについて
   はそのインデックス｡
7. 値: 連想配列の場合は値,`fill!(x, v)`の様な場合は`v`
8. その他のすべての引数
9. Varargs: 引数指定の最後に無限に指定できる引数｡`Matrix{T}(undef, dims)`の様な
   例では`dims`は`Tuple`(`Matrix{T}(undef, (1,2))`),あるいは`Vararg`型
   (`Matrix{T}(undef, 1 ,2)`)で与えられる｡
10. キーワード引数: Juliaにおけるキーワード引数は必ず最後に指定します｡

ここで言及されたすべての種類の引数を持つ関数は珍しいでしょう｡(リストの番号は単
に引数の優先度を表現しています｡)  

もちろん,この法則を適用する上で問題となる例もあります｡`convert`では常に最初の引
数に`Type`を要求します｡`setindex!`では,インデックスを`Vararg`として要求するので
,値が先にきます｡  

APIなどを設計するときは,この規則に従うことで利用者に一貫性のあるAPIを提供できる
でしょう｡


try-catchを使いすぎない
-----------------------

エラーのキャッチに頼るよりそれらを避けましょう｡


条件式を括弧で囲わない
---------------------

Juliaでは`if`や`while`の条件式を括弧で囲う必要がありません｡
```julia
if (a == b)
```
の代わりに
```julia
if a == b
```
と書きましょう｡


`...`を使いすぎない
-------------------

スプライシングの機能は中毒性があります｡`[a..., b...]`とかく代わりに`[a; b]`のよ
うに書きましょう(これは連結された配列になります)｡`[a...]`と書くより`collect(a)`
と書く方が良いです｡もし`a`がイテラブルなら配列に変換せずにそのままのほうが良い
こともあります｡


不要な静的パラメータを使わない
------------------------------

関数内部で`T`が使われない限り,関数シグニチャは
```julia
foo(x::T) where {T<:Real} = ...
```
より
```julia
foo(x::Real) = ...
```
のように書かれるべきです｡また使われていたとしても`typeof(x)`によって書き換える
こともできます｡これは静的パラメータの利用に関する一般的な助言ではなく,それが不
要な場合の話です｡  

コンテナ型も関数の呼び出し時に静的パラメータを使う必要が出てきます｡(FAQ: [Avoid
fields with abstract containers][2])


型とインスタンスの混同を避ける
------------------------------

以下の様な関数宣言は混同しやすくなります｡

```julia
foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)
```

`MyType`と`MyType()`の違いに注意しましょう｡  

インスタンスの利用を優先的に考えましょう｡`Type{MyType}`の利用はその後必要があれ
ば考えるようにします｡


マクロを濫用しない
------------------

マクロ内で`eval`を呼ぶような記述があれば注意が必要です｡この様なマクロは
top-levelスコープで呼ばれたときに作用します｡この様なマクロを関数に書き換えると
自然に実行時に変化する値に自然にアクセスできます｡


インタフェースレベルでunsafeな操作を記述しない
---------------------------------------------

```julia
mutable struct NativeType
    p::Ptr{UInt8}
    ...
end
```

この様な型に対して以下のようなメソッドを書くのは危険です｡

```julia
getindex(x::NativeType, i) = unsafe_load(x.p, i)
```

問題はユーザーがそれと知らずに`x[i]`の様な記述でunsafeな操作実行する可能性があ
ることです｡  

この様な関数は操作が安全だと検証するか,関数名にunsafeを含む必要があります｡


baseのコンテナ型に対してメソッドを追加しない
-------------------------------------------

```julia
show(io::IO, v::Vector{MyType} = ...
```

この様な記述は可能ですが混乱を招きます｡ユーザーは`Vector()`のようなよく知られた
型に対しては,いつも変わらない動作を期待しているため,過ぎたカスタマイズは使いに
くくなります｡


型の侵害を避ける
----------------

型の侵害とは自分の定義していない型に対してメソッドを宣言することです｡大して悪影
響がない場合もありますが,極端な場合にはJuliaがクラッシュすることもあります(例:
再定義あるいは拡張されたメソッドが`ccall`への無効な入力を引き起こす場合)｡コード
がわかりにくくなったり,原因が分かりにくい非互換性を作り出すこともあります｡  

以下のような,シンボルの乗算を定義する例を考えます｡

```julia
module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end
```

問題となるのは,`Base.*`を使う他のモジュールもこの定義を参照することになるという
点です｡`Symbol`がBaseで定義されていて他のモジュールからも使われるため,この定義
は他のモジュールで予期しない動作を引き起こすことになりかねません｡代替手段として
,関数名を変える,`Symbol`を独自の型で包むなどの方法があります｡  

対になっているパッケージは,機能の実装と型の定義を分離する際,特に著者が複数人い
る場合や型の定義に再利用性がある場合に型の侵害を実装することがあります｡例えば色
を扱うのに便利な型を定義したパッケージがあるとします｡他のパッケージで色空間を変
換するメソッドを定義することができます｡その他の例としてCのコードをラップしたパッ
ケージとJuliaフレンドリーなインタフェースを書いたパッケージを分けたものがありま
す｡


型の等価性に注意する
--------------------

型について調べるとき一般的には`isa`や`<:`が使われるでしょう｡型の厳密な等価性を
調べるのは,既知の具体型との比較(例: `T == Floate64`)か自分が正確に何をしようと
しているか分かっているときになります｡


`x->f(x)`と書かない
-------------------

高階関数はしばしば無名関数を引数として呼ばれるのでこの様な書き方は必要になって
くるでしょう｡しかし直接渡すことができる関数は直接渡すべきです｡`map(x->f(x), a)`
と書く代わりに`map(f, a)`と書きましょう｡


可能な限り一般的なコードで数値リテラルにfloatを使うことを避ける
---------------------------------------------------------------

もし数値を扱う一般的な(複数の異なる型の引数でで実行することが期待される)コード
を書くなら,可能な限り引数の型に影響を与えない数値型を選びましょう｡

```julia
julia> f(x) = 2.0 * x
f (generic function with 1 method)

julia> f(1//2)
1.0

julia> f(1/2)
1.0

julia> f(1)
2.0
```

の代わりに

```julia
julia> g(x) = 2 * x
g (generic function with 1 method)

julia> g(1//2)
1//1

julia> g(1/2)
1.0

julia> g(1)
2
```

のような書き方をしましょう｡見たとおり`Int`を使った2つ目の例では引数の型が保存さ
れています｡これはJuliaが乗算の際に起こす[promotion][3]が`Floate64`を優先する
(`promote_type(Int, Floate64) == Floate64`)ためです｡promotionとは異なる複数の型
の変数を一つの同じ型に変換することです｡`Rational`は`Floate64`よりも破壊的でない
が,`Int`よりは破壊的

```julia
julia> h(x) = 2//1 * x
h (generic function with 1 method)

julia> h(1//2)
1//1

julia> h(1/2)
1.0

julia> h(1)
2//1
```

非整数の数値型と同じ式では`Int`を可能ならば使うようにしましょう｡型が保存されて
コードが使いやすくなります｡


[1]: https://docs.julialang.org/en/v1/base/numbers/#Base.MathConstants.pi
[2]: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-fields-with-abstract-containers-1
[3]: https://docs.julialang.org/en/v1/base/base/#Base.promote_type
