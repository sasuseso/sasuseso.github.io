<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>Julia Style Guide (japanese)</title> <link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel=stylesheet > <div id=layout > <div id=menu > <ul> <li><i class="fas fa-home"></i><a href="/">Home</a> <li><i class="fas fa-tags"></i><a href="/tags">Tags</a> <li><i class="fas fa-scroll"></i><a href="/blog/posts">Posts</a> </ul> </div> <div id=main > <div class=franklin-content ><h1>Julia Style Guide</h1> <p><a href="https://docs.julialang.org/en/v1/manual/style-guide/index.html">https://docs.julialang.org/en/v1/manual/style-guide/index.html</a>のメモ </p> <p>以下はJuliaの慣用的なコーディングスタイルをまとめたものです｡このガイドは絶対で はなくJulia言語の上達の助けであり,設計の幅を広げるための提案です｡</p> <h2>関数にまとめる</h2> <p>Top-levelスコープにロジックを書きなぐれば問題自体は早く解決しますが,それらはで きるだけ早く関数にまとめるべきです｡関数にすることで書かれている処理が明確になり ,再利用とテストが簡単になります｡更にJuliaのコンパイラによって関数内の処理は top-levelのものより実行が高速になります｡また関数はできるだけ引数を取るように設 計してグローバル変数へのアクセスは押さえるべきです｡&#40;<a href="https://docs.julialang.org/en/v1/base/numbers/#Base.MathConstants.pi">pi</a>などの定数は例外&#41;</p> <h2>型を制限しすぎない</h2> <p>コードは可能な限り一般化されるべきです</p> <pre><code class="julia hljs"><span class=hljs-built_in >Complex</span>{<span class=hljs-built_in >Float64</span>}(x)</code></pre>
<p>上記より以下のように書かれるべきです</p>
<pre><code class="julia hljs">complex(float(x))</code></pre>
<p>2つ目のコードは自動的に<code>x</code>を適切な型に変換します｡  </p>
<p>これは関数の引数についても言えます｡任意の整数を引数に取りたい場合<code>Int</code>や<code>Int32</code> ではなく抽象型である<code>Integer</code>を使うべきです｡とは言えほとんどの場合関数の引数に は型注釈をつける必要はありません｡指定された型を引数に取るメソッドが宣言されてい なければ<code>MethodError</code>が投げられます｡</p>
<p>以下は例です｡<code>addone</code>は与えられた数値型の1と引数の和を返します｡</p>
<pre><code class="julia hljs">addone(x::<span class=hljs-built_in >Int</span>) = x + <span class=hljs-number >1</span>
addone(x::<span class=hljs-built_in >Integer</span>) = x + oneunit(x)
addone(x::<span class=hljs-built_in >Number</span>) = x + oneunit(x)
addone(x) = x + oneunit(x)</code></pre>
<p><code>addone</code>は<code>oneunit</code>がサポートするすべての型と<code>&#43;</code>関数が定義されている型を受け付 けます｡注目するべきは,引数に型注釈がついているものとそうでないものの間には一切 のパフォーマンスの差が無いことです｡</p>
<pre><code class="julia hljs">ベンチいれとこうかな</code></pre>
<p>Juliaの処理系は自動的に最適化されたバージョンをコンパイルしてくれます｡例えば,最 初に<code>addone&#40;12&#41;</code>として呼び出した時,処理系は<code>x::Int64</code>に最適化された<code>addone</code>をコ ンパイルします｡つまり,上の3つの関数宣言は4番目の<code>addone</code>の宣言と同じになります｡</p>
<h2>型を広く取りすぎない</h2>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo(x, y)
    x = <span class=hljs-built_in >Int</span>(x); y = <span class=hljs-built_in >Int</span>(y)
    ...
<span class=hljs-keyword >end</span>
foo(x, y)</code></pre>
<p>とかく代わりに下の様に書くべきです｡</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo(x::<span class=hljs-built_in >Int</span>, y::<span class=hljs-built_in >Int</span>)
    ...
<span class=hljs-keyword >end</span>
foo(<span class=hljs-built_in >Int</span>(x), <span class=hljs-built_in >Int</span>(y))</code></pre>
<p><code>foo</code>は実際にはすべての型を受け入れるわけではないのでこの様に書くほうが良いです｡  </p>
<p>ここで問題なのはこの関数が本当は整数を引数に必要としていることです｡なので呼び出 し側に整数型を強制して,他の型からの変換&#40;例: 小数型の場合切り上げか切り捨てか&#41;を 担保させた方が良いと思われます｡もう一つの問題は,型注釈が具体的なため将来的にメ ソッド増える可能性があることです｡</p>
<h2>引数にとった変数を変更する関数の名前には<code>&#33;</code>をつける</h2>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> double(a::<span class=hljs-built_in >AbstractArray</span>{&lt;:<span class=hljs-built_in >Number</span>})
    <span class=hljs-keyword >for</span> i = firstindex(a):lastindex(a)
        a[i] *= <span class=hljs-number >2</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> a
<span class=hljs-keyword >end</span></code></pre>
<p>の代わりに</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> double!(a::<span class=hljs-built_in >AbstractArray</span>{&lt;:<span class=hljs-built_in >Number</span>})
    <span class=hljs-keyword >for</span> i = firstindex(a):lastindex(a)
        a[i] *= <span class=hljs-number >2</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> a
<span class=hljs-keyword >end</span></code></pre>
<p>を使うべきです｡  </p>
<p>Juliaの標準ライブラリのBaseモジュールはこの命名規則を使った例が多くあります｡ま た同じ機能でコピーが発生するものと引数を変更する2つのバージョンを持つ関数と&#40;例: sort, sort&#33;&#41;引数を変更するだけのものがあります&#40;例: push&#33;, pop&#33;, splice&#33;&#41;｡変更し た引数を返す関数にもこれは適用されます｡</p>
<h2>変な<code>Union</code>を使わない</h2>
<p><code>Union&#123;Function,AbstractString&#125;</code>の様な変な型を使わざるを得ないとう言うことは設 計に欠陥がある可能性を示唆しています｡</p>
<h2>凝ったコンテナ型を避ける</h2>
<p>以下のような型指定で<code>Union</code>に大量の型を指定するより</p>
<pre><code class="julia hljs">a = <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Int</span>,<span class=hljs-built_in >AbstractString</span>,<span class=hljs-built_in >Tuple</span>,<span class=hljs-built_in >Array</span>}}(undef, n)</code></pre>
<p>単純に<code>Vector&#123;Any&#125;&#40;undef, n&#41;</code>として要素を利用するときに型注釈をつける&#40;例: <code>a&#91;i&#93;::Int</code>&#41;ほうがコンパイラは喜びます｡</p>
<h2>Juliaの<code>base/</code>で使われている命名規則を使う</h2>
<ul>
<li><p>モジュールと型はアッパーキャメルケース&#40;例: <code>SparseArrays</code>, <code>struct UnitRange</code>&#41;</p>

<li><p>関数は基本的には小文字です｡&#40;例: <code>maximum</code>, <code>convert</code>&#41; また,読みやすい限り複数 の単語で構成される名前も小文字です｡&#40;<code>isequal</code>, <code>haskey</code>&#41; 必要ならアンダースコ アを単語の区切りに用います｡ アンダースコアは複合的な意味を表現したいときにも 用います｡&#40;<code>fetch&#40;remotecall&#40;...&#41;&#41;</code>の別名として<code>remotecall_fetch</code>とします&#41;</p>

<li><p>簡潔さを重視しますが,分かりにくい略語&#40;○<code>indexin</code>, ☓<code>indxin</code>&#41;を避けましょう｡</p>

</ul>
<p>関数名が複数の単語を必要とするときは,それが複数の概念を表現する必要があるかどう か考えてより良い分割がないかを考慮しましょう｡</p>
<h2>関数の引数の順序をJuliaの<code>Base</code>を参考にする</h2>
<p>一般的に<code>Base</code>は以下のルールに従って引数の順序を決定しています｡</p>
<ol>
<li><p><code>Function</code>型: <code>Function</code>を引数とする関数は,これを第一引数とすることで<code>do</code>ブ ロックによって無名関数を渡すことが可能になります｡</p>

<li><p>I/Oストリーム: <code>IO</code>のオブジェクトを引数を最初に指定することで<code>sprint</code>の様な 関数に<code>Function</code>を渡すことができます｡</p>

<li><p>ミュータブルな入力: 引数に指定された変数の値を変更する関数でミュータブルにさ れる引数は最初に来ます｡例えば<code>fill&#33;&#40;x, v&#41;</code>では<code>x</code>がミュータブルになり,<code>v</code>に 書換えられます｡</p>

<li><p><code>Type</code>: 型が引数として与えられるときは,その関数から返る値はそこで指定された 型であることが一般的です｡<code>parse&#40;Int, &quot;1&quot;&#41;</code>では,型がパースされる文字列の前に 来ます｡</p>

<li><p>イミュータブルな入力: イミュータブルな引数はミュータブルな引数の後に指定され ます｡&#40;<code>fill&#33;&#40;x, v&#41;</code>の<code>v</code>&#41;</p>

<li><p>キー: 連想配列のキー<code>Array</code>などの他のインデックス可能なオブジェクトについて はそのインデックス｡</p>

<li><p>値: 連想配列の場合は値,<code>fill&#33;&#40;x, v&#41;</code>の様な場合は<code>v</code></p>

<li><p>その他のすべての引数</p>

<li><p>Varargs: 引数指定の最後に無限に指定できる引数｡<code>Matrix&#123;T&#125;&#40;undef, dims&#41;</code>の様な 例では<code>dims</code>は<code>Tuple</code>&#40;<code>Matrix&#123;T&#125;&#40;undef, &#40;1,2&#41;&#41;</code>&#41;,あるいは<code>Vararg</code>型 &#40;<code>Matrix&#123;T&#125;&#40;undef, 1 ,2&#41;</code>&#41;で与えられる｡</p>

<li><p>キーワード引数: Juliaにおけるキーワード引数は必ず最後に指定します｡</p>

</ol>
<p>ここで言及されたすべての種類の引数を持つ関数は珍しいでしょう｡&#40;リストの番号は単 に引数の優先度を表現しています｡&#41;  </p>
<p>もちろん,この法則を適用する上で問題となる例もあります｡<code>convert</code>では常に最初の引 数に<code>Type</code>を要求します｡<code>setindex&#33;</code>では,インデックスを<code>Vararg</code>として要求するので ,値が先にきます｡  </p>
<p>APIなどを設計するときは,この規則に従うことで利用者に一貫性のあるAPIを提供できる でしょう｡</p>
<h2>try-catchを使いすぎない</h2>
<p>エラーのキャッチに頼るよりそれらを避けましょう｡</p>
<h2>条件式を括弧で囲わない</h2>
<p>Juliaでは<code>if</code>や<code>while</code>の条件式を括弧で囲う必要がありません｡</p>
<pre><code class="julia hljs"><span class=hljs-keyword >if</span> (a == b)</code></pre>
<p>の代わりに</p>
<pre><code class="julia hljs"><span class=hljs-keyword >if</span> a == b</code></pre>
<p>と書きましょう｡</p>
<h2><code>...</code>を使いすぎない</h2>
<p>スプライシングの機能は中毒性があります｡<code>&#91;a..., b...&#93;</code>とかく代わりに<code>&#91;a; b&#93;</code>のよ うに書きましょう&#40;これは連結された配列になります&#41;｡<code>&#91;a...&#93;</code>と書くより<code>collect&#40;a&#41;</code> と書く方が良いです｡もし<code>a</code>がイテラブルなら配列に変換せずにそのままのほうが良い こともあります｡</p>
<h2>不要な静的パラメータを使わない</h2>
<p>関数内部で<code>T</code>が使われない限り,関数シグニチャは</p>
<pre><code class="julia hljs">foo(x::T) <span class=hljs-keyword >where</span> {T&lt;:<span class=hljs-built_in >Real</span>} = ...</code></pre>
<p>より</p>
<pre><code class="julia hljs">foo(x::<span class=hljs-built_in >Real</span>) = ...</code></pre>
<p>のように書かれるべきです｡また使われていたとしても<code>typeof&#40;x&#41;</code>によって書き換える こともできます｡これは静的パラメータの利用に関する一般的な助言ではなく,それが不 要な場合の話です｡  </p>
<p>コンテナ型も関数の呼び出し時に静的パラメータを使う必要が出てきます｡&#40;FAQ: <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-fields-with-abstract-containers-1">Avoid fields with abstract containers</a>&#41;</p>
<h2>型とインスタンスの混同を避ける</h2>
<p>以下の様な関数宣言は混同しやすくなります｡</p>
<pre><code class="julia hljs">foo(::<span class=hljs-built_in >Type</span>{MyType}) = ...
foo(::MyType) = foo(MyType)</code></pre>
<p><code>MyType</code>と<code>MyType&#40;&#41;</code>の違いに注意しましょう｡  </p>
<p>インスタンスの利用を優先的に考えましょう｡<code>Type&#123;MyType&#125;</code>の利用はその後必要があれ ば考えるようにします｡</p>
<h2>マクロを濫用しない</h2>
<p>マクロ内で<code>eval</code>を呼ぶような記述があれば注意が必要です｡この様なマクロは top-levelスコープで呼ばれたときに作用します｡この様なマクロを関数に書き換えると 自然に実行時に変化する値に自然にアクセスできます｡</p>
<h2>インタフェースレベルでunsafeな操作を記述しない</h2>
<pre><code class="julia hljs"><span class=hljs-keyword >mutable struct</span> NativeType
    p::<span class=hljs-built_in >Ptr</span>{<span class=hljs-built_in >UInt8</span>}
    ...
<span class=hljs-keyword >end</span></code></pre>
<p>この様な型に対して以下のようなメソッドを書くのは危険です｡</p>
<pre><code class="julia hljs">getindex(x::NativeType, i) = unsafe_load(x.p, i)</code></pre>
<p>問題はユーザーがそれと知らずに<code>x&#91;i&#93;</code>の様な記述でunsafeな操作実行する可能性があ ることです｡  </p>
<p>この様な関数は操作が安全だと検証するか,関数名にunsafeを含む必要があります｡</p>
<h2>baseのコンテナ型に対してメソッドを追加しない</h2>
<pre><code class="julia hljs">show(io::<span class=hljs-built_in >IO</span>, v::<span class=hljs-built_in >Vector</span>{MyType} = ...</code></pre>
<p>この様な記述は可能ですが混乱を招きます｡ユーザーは<code>Vector&#40;&#41;</code>のようなよく知られた 型に対しては,いつも変わらない動作を期待しているため,過ぎたカスタマイズは使いに くくなります｡</p>
<h2>型の侵害を避ける</h2>
<p>型の侵害とは自分の定義していない型に対してメソッドを宣言することです｡大して悪影 響がない場合もありますが,極端な場合にはJuliaがクラッシュすることもあります&#40;例: 再定義あるいは拡張されたメソッドが<code>ccall</code>への無効な入力を引き起こす場合&#41;｡コード がわかりにくくなったり,原因が分かりにくい非互換性を作り出すこともあります｡  </p>
<p>以下のような,シンボルの乗算を定義する例を考えます｡</p>
<pre><code class="julia hljs"><span class=hljs-keyword >module</span> A
<span class=hljs-keyword >import</span> Base.*
*(x::<span class=hljs-built_in >Symbol</span>, y::<span class=hljs-built_in >Symbol</span>) = <span class=hljs-built_in >Symbol</span>(x,y)
<span class=hljs-keyword >end</span></code></pre>
<p>問題となるのは,<code>Base.*</code>を使う他のモジュールもこの定義を参照することになるという 点です｡<code>Symbol</code>がBaseで定義されていて他のモジュールからも使われるため,この定義 は他のモジュールで予期しない動作を引き起こすことになりかねません｡代替手段として ,関数名を変える,<code>Symbol</code>を独自の型で包むなどの方法があります｡  </p>
<p>対になっているパッケージは,機能の実装と型の定義を分離する際,特に著者が複数人い る場合や型の定義に再利用性がある場合に型の侵害を実装することがあります｡例えば色 を扱うのに便利な型を定義したパッケージがあるとします｡他のパッケージで色空間を変 換するメソッドを定義することができます｡その他の例としてCのコードをラップしたパッ ケージとJuliaフレンドリーなインタフェースを書いたパッケージを分けたものがありま す｡</p>
<h2>型の等価性に注意する</h2>
<p>型について調べるとき一般的には<code>isa</code>や<code>&lt;:</code>が使われるでしょう｡型の厳密な等価性を 調べるのは,既知の具体型との比較&#40;例: <code>T &#61;&#61; Floate64</code>&#41;か自分が正確に何をしようと しているか分かっているときになります｡</p>
<h2><code>x-&gt;f&#40;x&#41;</code>と書かない</h2>
<p>高階関数はしばしば無名関数を引数として呼ばれるのでこの様な書き方は必要になって くるでしょう｡しかし直接渡すことができる関数は直接渡すべきです｡<code>map&#40;x-&gt;f&#40;x&#41;, a&#41;</code> と書く代わりに<code>map&#40;f, a&#41;</code>と書きましょう｡</p>
<h2>可能な限り一般的なコードで数値リテラルにfloatを使うことを避ける</h2>
<p>もし数値を扱う一般的な&#40;複数の異なる型の引数でで実行することが期待される&#41;コード を書くなら,可能な限り引数の型に影響を与えない数値型を選びましょう｡</p>
<pre><code class="julia hljs">julia&gt; f(x) = <span class=hljs-number >2.0</span> * x
f (generic <span class=hljs-keyword >function</span> with <span class=hljs-number >1</span> method)

julia&gt; f(<span class=hljs-number >1</span>//<span class=hljs-number >2</span>)
<span class=hljs-number >1.0</span>

julia&gt; f(<span class=hljs-number >1</span>/<span class=hljs-number >2</span>)
<span class=hljs-number >1.0</span>

julia&gt; f(<span class=hljs-number >1</span>)
<span class=hljs-number >2.0</span></code></pre>
<p>の代わりに</p>
<pre><code class="julia hljs">julia&gt; g(x) = <span class=hljs-number >2</span> * x
g (generic <span class=hljs-keyword >function</span> with <span class=hljs-number >1</span> method)

julia&gt; g(<span class=hljs-number >1</span>//<span class=hljs-number >2</span>)
<span class=hljs-number >1</span>//<span class=hljs-number >1</span>

julia&gt; g(<span class=hljs-number >1</span>/<span class=hljs-number >2</span>)
<span class=hljs-number >1.0</span>

julia&gt; g(<span class=hljs-number >1</span>)
<span class=hljs-number >2</span></code></pre>
<p>のような書き方をしましょう｡見たとおり<code>Int</code>を使った2つ目の例では引数の型が保存さ れています｡これはJuliaが乗算の際に起こす<a href="https://docs.julialang.org/en/v1/base/base/#Base.promote_type">promotion</a>が<code>Floate64</code>を優先する &#40;<code>promote_type&#40;Int, Floate64&#41; &#61;&#61; Floate64</code>&#41;ためです｡promotionとは異なる複数の型 の変数を一つの同じ型に変換することです｡<code>Rational</code>は<code>Floate64</code>よりも破壊的でない が,<code>Int</code>よりは破壊的</p>
<pre><code class="julia hljs">julia&gt; h(x) = <span class=hljs-number >2</span>//<span class=hljs-number >1</span> * x
h (generic <span class=hljs-keyword >function</span> with <span class=hljs-number >1</span> method)

julia&gt; h(<span class=hljs-number >1</span>//<span class=hljs-number >2</span>)
<span class=hljs-number >1</span>//<span class=hljs-number >1</span>

julia&gt; h(<span class=hljs-number >1</span>/<span class=hljs-number >2</span>)
<span class=hljs-number >1.0</span>

julia&gt; h(<span class=hljs-number >1</span>)
<span class=hljs-number >2</span>//<span class=hljs-number >1</span></code></pre>
<p>非整数の数値型と同じ式では<code>Int</code>を可能ならば使うようにしましょう｡型が保存されて コードが使いやすくなります｡</p>
<p></p>
<div class=page-foot >
    <div class=contactme >
        <a href="https://twitter.com/_sasuseso">Twitter</a> /
        <a href="https://github.com/sasuseso">GitHub</a>
    </div>
  <div class=copyright >
    &copy; sasuseso. Last modified: August 06, 2020. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>
</div>
        </div> 
    </div>